// Copyright 2023 Cisco Systems, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import TemplateProcessor from './TemplateProcessor.js';
import * as repl from 'repl';
import {stringifyTemplateJSON} from "./utils/stringify.js";
import jsonata from "jsonata";
import {CliCoreBase} from "./CliCoreBase.js";


export default class CliCore extends CliCoreBase{
    //@ts-ignore
    public replServer:repl.REPLServer;

    constructor(templateProcessor: TemplateProcessor) {
        super(templateProcessor);
    }


    public async tail(args: string): Promise<any> {
        console.log("Started tailing... Press Ctrl+C to stop.")
        let {jsonPointer, number:countDown=NaN, jsonataExpression="false"} = this.extractArgsInfo(args);
        const compiledExpr = jsonata(jsonataExpression);

        let currentOutputLines = 0;

        // SIGINT listener to handle Ctrl+C press in REPL
        const onSigInt = () => {
            unplug();
        };

        // If this.replServer is defined (not in tests), register the SIGINT listener
        if (this.replServer) {
            this.replServer.on('SIGINT', onSigInt);
        }

        let resolve: ()=>void; //resolve function that will act as a latch to cause tail to return when the 'until' criterion is met
        // Function to stop tailing
        const unplug = () => {
            // Stop tailing without clearing the screen to keep the exit message
            this.templateProcessor.removeDataChangeCallback(jsonPointer);

            // If this.replServer is defined (not in tests), display the prompt and remove the SIGINT listener
            if (this.replServer) {
                this.replServer.removeListener('SIGINT', onSigInt);
            }
        };

        let _data;
        let done = false;
        // Data change callback
        const onDataChanged = async (data: any) => {
            if(done){
                return; //just ignore any latent callbacks
            }
            // Convert data to a string
            const output = stringifyTemplateJSON(data);
            _data = JSON.parse(output); //save data so we can return the final value from the promise. It is important to return a snapshot via reparsing from string so that returned objects don't continue to 'evolve' and make testing impossible
            const outputLines = output.split('\n');


            // If in overwrite mode and output lines exist, move cursor up to clear previous lines
            for (let i = 0; i < currentOutputLines; i++) {
                //when we are running tests like from README.md autogenerated tests, there is no repl server
                //so we must check to make sure it exists before we write it
                this.replServer && this.replServer.output.write('\x1B[1A\x1B[K'); // Clear the line
            }


            if(isNaN(countDown) || countDown > 0) { //since the last value will be returned from this method and written by the REPL, we should not print it to screen
                // Write new data to the output
                this.replServer && this.replServer.output.write(output + '\n');
                // Update the current output lines count for the next change
                currentOutputLines = outputLines.length;
            }

            if(!isNaN(countDown)){
                countDown--;
            }

            if(countDown === 0 || await compiledExpr.evaluate(data)===true){ //check if the expression in the 'until' argument (the stop tailing condition) has evaluated to true
                done = true;
                unplug();
                resolve(); //resolve the latch promise
            }
        };


        // If countDown is greater than zero, return the Promise that resolves when countDown is zero
        const latch = new Promise<void>((_resolve) => {
                resolve = _resolve; //we assign our resolve variable that is declared outside this promise so that our onDataChange callbacks can use  it
        });

        // Register the onDataChanged callback with the templateProcessor
        this.templateProcessor.setDataChangeCallback(jsonPointer, onDataChanged);

        await latch; //waits for a onDataChanged callback to resolve the latch.

        return {
            "__tailed": true,
            "data":_data
        }; //the last result tailed to the screen is what this command returns
    }

}

